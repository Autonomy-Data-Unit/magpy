# AUTOGENERATED! DO NOT EDIT! File to edit: ../../../pts/api/extract/schema.pct.py.

# %% auto 0
__all__ = ['Field']

# %% ../../../pts/api/extract/schema.pct.py 3
from typing import Union, Dict, Any, Type, get_args, get_origin, List, Optional
from datetime import datetime
import pydantic
import json
from pydantic import BaseModel, Field as PydanticField, create_model

# %% ../../../pts/api/extract/schema.pct.py 4
class Field:
    """Schema field definition with type enforcement, descriptions, and optional fields."""
    
    def __init__(
        self, 
        field_type: Any,
        desc: Optional[str] = None, 
        optional: bool = False
    ):
        self.field_type = field_type
        self.desc = desc
        self.optional = optional

# %% ../../../pts/api/extract/schema.pct.py 5
def _convert_field_to_type(field: Field) -> tuple:
    """
    Converts a custom Field into a (type_annotation, FieldInfo) tuple for Pydantic
    """
    desc = field.desc or ""
    annotation = _parse_type(field.field_type)
    if field.optional:
        annotation = Optional[annotation]
    return (annotation, PydanticField(... if not field.optional else None, description=desc))

def _parse_type(field_type: Union[Type, Dict, list, tuple]) -> Any:
    """
    Recursively resolve field_type to proper typing annotations for Pydantic
    """
    if isinstance(field_type, dict):
        # Nested object -> create a dynamic Pydantic model
        return _create_dynamic_model(field_type)
    
    origin = get_origin(field_type)
    if origin is list or origin is List:
        (item_type,) = get_args(field_type)
        return List[_parse_type(item_type)]
    
    return field_type  # e.g., str, int, datetime

def _create_dynamic_model(schema_dict: Dict[str, Field], model_name: str = "ResponseModel") -> Type[BaseModel]:
    """
    Create a Pydantic model from a dictionary of Field instances
    """
    fields = {}
    for field_name, field_def in schema_dict.items():
        if not isinstance(field_def, Field): # if the field is not a Field, then we presume it is a type
            field_def = Field(field_def)
        fields[field_name] = _convert_field_to_type(field_def)

    model = create_model(model_name, **fields)
    
    # Monkey-patch __config__ to disable additional properties
    class Config:
        extra = "forbid"
    model.__config__ = Config
    return model

# %% ../../../pts/api/extract/schema.pct.py 6
from openai.types.chat.completion_create_params import ResponseFormat as OpenAIResponseFormatParam

def _pydantic_to_response_format_param(
    model: Type[pydantic.BaseModel] | Type[Any]
) -> OpenAIResponseFormatParam:
    """
    Convert a Pydantic model to OpenAI's response_format parameter.
    
    This function returns the complete response_format parameter structure
    that can be passed directly to the OpenAI API.
    
    Args:
        model: A Pydantic model class (BaseModel or dataclass-like)
        
    Returns:
        OpenAIResponseFormatParam: The complete response_format parameter
        
    Raises:
        TypeError: If the model type is not supported
    """
    from openai.lib._parsing import type_to_response_format_param
    from openai._types import NOT_GIVEN
    
    response_format = type_to_response_format_param(model)
    
    if response_format is NOT_GIVEN:
        raise TypeError(f"Could not convert model {model} to response format")
    
    return response_format
